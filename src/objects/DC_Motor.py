# Class: DC_Motor.py
# Author: John Morris, jhmrrs@clemson.edu
# Date: 30 June 2022
# Purpose: Describes the response of a DC motor given a set of physcial and eletrical
#   constants. Also calls an integrator to solve that response.
# Sources: 
#   1.  Derivation of state equations from Chen, Y., (2015). Modeling of
#       DC Motor, NCTU Dept. of Electrical and Computer Engineering. 
#       http://ocw.nctu.edu.tw/course/dssi032/DSSI_2.pdf
# Permissions: All rights reserved. Do not reuse without written permission from the owner.

import numpy as np
from scipy import signal
from src.simulation.ss_solver import ss_solver
from src.analysis.charts import plotSimResults

class DC_Motor:
    def __init__(self, resistance_armature=0.5, winding_leakage_inductance=1.5e-3, 
                 rotor_moment_of_intertia=2.5e-4, torque_constant=0.05, frictional_coefficient=1e-4):
        '''
        Inputs
        ---
        * resistance_armature (R_a, Ohms) : float=0.5
        * winding_leakage_inductance (L_a, Hertz) : float=1.5e-3
        * rotor_moment_of_inertia (J_M, N-m/(rad/s^2)) : float=2.5e-4
        * torque_constant (k, N-m/A), equivalent to back-EMF constant : float=0.05
        * frictional_coefficient (B_M, N-m/(rad/s)) : float=1e-4

        States
        ---
        * theta (rad), angular position, measured CCW from the abscissa
        * omega (rad/s), angular velocity, with CCW as positive
        * torque_of_payload (T_L, N-m), Torque applied to the motor from the payload
        * armature_current (i_a, A), current supplied to motor
        '''
        self.R_a = resistance_armature
        self.L_a = winding_leakage_inductance
        self.J_M = rotor_moment_of_intertia
        self.k = torque_constant
        self.B_M = frictional_coefficient

        # State Variables
        self.sys = self.createStateSpace()

    def createStateSpace(self) -> signal.StateSpace:
        '''
        States:
        ---
        1. i_a
        2. omega
        3. theta

        Inputs:
        ---
        1. v_s
        2. T_L

        Outputs:
        ---
        1. omega
        2. theta
        '''
        A = np.array([[-self.R_a / self.L_a, -self.k / self.L_a, 0],
                      [self.k / self.J_M, -self.B_M / self.J_M, 0],
                      [0, 1, 0]])
        B = np.array([[1 / self.L_a, 0],
                      [0, -1 / self.J_M],
                      [0, 0]])
        C = np.array([[0, 1, 0]])
        D = np.array([[0, 0]])
        return signal.StateSpace(A, B, C, D)

    def simulateMotor(self, time : list, voltage_source : list, torque_of_payload : list, 
                      i_a_0: float=0., omega_0: float=0., theta_0: float=0., to_plot: bool=False) -> tuple:
        '''
        Simulate the motor response.
        
        Inputs:
        ---
        time : list
            Every time in the system to solve for a system response
        voltage_source : list
            The input voltage to the motor at every time step in <time>
        torque_of_payload : list
            The torque of the payload on the motor at every time step in <time>
        i_a_0 : float=0.
            The initial current to the motor (A)
        omega_0 : float=0.
            The initial angular roation (rad/s)
        theta_0 : float=0.
            The initial angular position (rad)
        to_plot : bool=False
            True if desired to chart results of simulation
        '''
        #TODO: These motors are coupled, and cannot be solved for independently. This simulation needs to be
        #brought over to the Tank.py file, and then the relationship between the MoI for tank compared to their individual
        #motions should be solved for.
        
        v_s = np.array(voltage_source)
        T_L = np.array(torque_of_payload)

        U = np.column_stack((v_s, T_L))
        x0 = [i_a_0, omega_0, theta_0]
        T, Y, X = ss_solver(self.sys, time, U, x0)
        if to_plot: plotSimResults(T, Y, X)
        return T, Y, X

    def getGeneratedTorque(self, input_current):
        ''' Calculates the torque generated by the motor for the given current.'''
        i_a = input_current
        T_m = self.k * i_a
        if input_current is None:
            self.T_m = T_m
        return T_m
